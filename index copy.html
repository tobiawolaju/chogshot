<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Planet + Swirling Clouds</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

const scene = new THREE.Scene();
const cam = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const planetRadius = 5;
const playerRadius = 0.5;
const cameraDistance = 13;
let activePlayerId = "player1";

let yaw = 0;
let pitch = Math.PI / 2;
let radius = cameraDistance;

const bgScene = new THREE.Scene(), bgCam = new THREE.Camera();
const bgMat = new THREE.ShaderMaterial({
  vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
  fragmentShader: `
    uniform vec3 topColor, middleColor, bottomColor; uniform float vh;
    void main() {
      float g = gl_FragCoord.y / vh;
      vec3 c = g < 0.5 ? mix(bottomColor, middleColor, g*2.0) : mix(middleColor, topColor, (g-0.5)*2.0);
      gl_FragColor = vec4(c, 1.0);
    }
  `,
  uniforms: {
    topColor: { value: new THREE.Color(0xE4EFFF) },
    middleColor: { value: new THREE.Color(0xFFFFFF) },
    bottomColor: { value: new THREE.Color(0xF7DDFF) },
    vh: { value: innerHeight }
  },
  depthWrite: false, depthTest: false, side: THREE.DoubleSide
});
bgScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), bgMat));

const planet = new THREE.Mesh(
  new THREE.SphereGeometry(planetRadius, 128, 128),
  new THREE.ShaderMaterial({
    vertexShader: `
      varying vec3 vNormal;
      varying vec2 vUv;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vNormal;
      varying vec2 vUv;
      float line(float val, float target, float thickness) {
        return smoothstep(target - thickness, target, val) - smoothstep(target, target + thickness, val);
      }
      float drawCourt(vec2 uv) {
        float t = 0.0025;
        float result = 0.0;
        float d = distance(uv, vec2(0.5, 0.5));
        result += smoothstep(0.06 + t, 0.06, d) - smoothstep(0.06, 0.06 - t, d);
        result += line(uv.x, 0.5, t);
        result += line(uv.y, 0.2, t);
        result += line(uv.y, 0.8, t);
        result += line(uv.x, 0.3, t);
        result += line(uv.x, 0.7, t);
        result += line(uv.y, 0.35, t);
        result += line(uv.y, 0.65, t);
        return clamp(result, 0.0, 1.0);
      }
      void main() {
        vec3 courtColor = vec3(1.0, 0.8, 1.0);
        vec3 lineColor = vec3(0.5, 0.5, 1.0);
        float lines = drawCourt(vUv);
        vec3 color = mix(courtColor, lineColor, lines);
        vec3 lightDir = normalize(vec3(0.3, 0.5, 1.0)); 
        float diffuse = max(dot(vNormal, lightDir), 0.0);
        color *= diffuse + 0.2;
        gl_FragColor = vec4(color, 1.0);
      }
    `,
    side: THREE.DoubleSide
  })
);
scene.add(planet);

// Lighting - 4 shepherd lights around the planet
const lightIntensity = 1;
const lightDistance = 1;

const lights = [
  new THREE.DirectionalLight(0xffffff, lightIntensity/2), // Right
  new THREE.DirectionalLight(0x00bcd4, lightIntensity), // Left
  new THREE.DirectionalLight(0xffed3f, lightIntensity), // Top
  new THREE.DirectionalLight(0xffffff, lightIntensity)  // Bottom
];

// Position the lights around the planet like satellites
lights[0].position.set(lightDistance, 10, 0);   // +X
lights[1].position.set(-lightDistance, 100, 0);  // -X
lights[2].position.set(0, lightDistance, 20);   // +Y
lights[3].position.set(200, -lightDistance, 0);  // -Y

lights.forEach(light => {
  light.castShadow = false; // optional
  scene.add(light);
});

// Ambient light to soften shadows
scene.add(new THREE.AmbientLight(0x444444));


// Starfield
const stars = new THREE.Object3D();
const starGeo = new THREE.TetrahedronGeometry(2, 0);
const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
for (let i = 0; i < 500; i++) {
  const star = new THREE.Mesh(starGeo, starMat);
  star.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
  star.position.multiplyScalar(90 + Math.random() * 700);
  star.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
  stars.add(star);
}
scene.add(stars);

// Players
const loader = new GLTFLoader();
const players = {};

function addPlayer(pos, id) {
  loader.load('basketball.glb', gltf => {
    const mesh = gltf.scene;
    mesh.scale.set(playerRadius, playerRadius, playerRadius);
    mesh.position.copy(pos);
    scene.add(mesh);
    players[id] = { mesh, velocity: new THREE.Vector3() };
  });
}

[
  ["player1", 0.000, 10.500, 0.000],
  ["player2", 2.960, 10.124, 2.313],
  ["player3", -2.660, 9.367, -3.712],
  ["player4", 4.564, 8.172, 1.855],
  ["player5", -4.853, 6.506, 0.543],
  ["player6", 3.526, 4.358, -3.985],
  ["player7", -0.993, 1.742, 5.860],
  ["player8", -2.238, -1.261, -5.593],
  ["player9", 4.312, -4.527, 1.967],
  ["player10", -5.060, -7.847, -0.384],
  ["player11", 3.627, -10.782, 2.622],
  ["player12", -1.190, -12.782, -5.148],
  ["player13", -1.647, -13.976, 5.083],
  ["player14", 3.278, -14.020, -3.744],
  ["player15", -4.759, -12.690, 1.234],
  ["player16", 5.250, -10.000, 0.000]
].forEach(([id, x, y, z]) => addPlayer(new THREE.Vector3(x, y, z), id));


function createCloudShaderMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        cloudsSpeed: { value: 0.2 },
        cloudsDirection: { value: 0.2 },
        cloudsScale: { value: 1.0 },
        cloudsCutoff: { value: 0.3 },
        cloudsFuzziness: { value: 0.5 },
        cloudsColor: { value: new THREE.Color(1.0, 1.0, 1.0) },
        edgeFade: { value: 0.25 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float time, cloudsSpeed, cloudsDirection, cloudsScale, cloudsCutoff, cloudsFuzziness, edgeFade;
        uniform vec3 cloudsColor;

        float hash(vec2 p) {
          return fract(sin(dot(p ,vec2(127.1,311.7))) * 43758.5453);
        }
        float noise(vec2 p){
          vec2 i = floor(p), f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        float edge(vec2 uv) {
          vec2 f = smoothstep(vec2(0.0), vec2(edgeFade), uv);
          f *= smoothstep(vec2(0.0), vec2(edgeFade), 1.0 - uv);
          return f.x * f.y;
        }
        void main() {
          vec2 uv = vUv * cloudsScale;
          vec2 dir = vec2(sin(cloudsDirection * 6.2831), cos(cloudsDirection * 6.2831));
          vec2 moved = uv + dir * time * cloudsSpeed * 0.01;
          float n = (noise(moved * 1.0) + noise(moved * 2.0) + noise(moved * 4.0)) / 3.0;
          float alpha = smoothstep(cloudsCutoff, cloudsCutoff + cloudsFuzziness, n);
          gl_FragColor = vec4(cloudsColor, alpha * edge(vUv));
        }
      `,
      transparent: true,
      depthWrite: false
    });
  }

function addCloudCluster(pos) {
    const cloudGroup = new THREE.Group();
    const up = pos.clone().sub(planet.position).normalize();
    const cloudDistance = planetRadius + 5;
    const center = planet.position.clone().add(up.multiplyScalar(cloudDistance));
    const spiralTightness = 0.3, spiralGrowth = 0.2, totalPuffs = 60, spiralTurns = 4;

    for (let i = 0; i < totalPuffs; i++) {
      const angle = (i / totalPuffs) * spiralTurns * Math.PI * 2;
      const r = spiralTightness * Math.exp(spiralGrowth * angle);
      const x = r * Math.cos(angle);
      const y = (i / totalPuffs) * 4 - 2;
      const z = r * Math.sin(angle);
      const puffPosition = new THREE.Vector3(x, y, z).add(new THREE.Vector3(
        (Math.random() - 0.5) * 0.8,
        (Math.random() - 0.5) * 0.6,
        (Math.random() - 0.5) * 0.8
      ));
      const puff = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.25 + Math.random() * 0.2, 1),
        createCloudShaderMaterial()
      );
      puff.position.copy(center.clone().add(puffPosition));
      puff.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      const scale = 0.8 + Math.random() * 0.5;
      puff.scale.set(scale, scale * 0.8, scale);
      cloudGroup.add(puff);
    }
    cloudGroup.tick = delta => cloudGroup.rotation.y += 0.05 * delta;
    scene.add(cloudGroup);
    return cloudGroup;
  }

  const cloudClusters = [
    new THREE.Vector3(2, 5, 1), new THREE.Vector3(-3, -2, 4),
    new THREE.Vector3(4, -3, -5), new THREE.Vector3(-5, 2, -2),
    new THREE.Vector3(0, -4, 5)
  ].map(pos => addCloudCluster(pos));


// Control
function control(id, action) {
  const player = players[id];
  if (!player) return;

  const { mesh, velocity } = player;
  const up = mesh.position.clone().sub(planet.position).normalize();
  const right = new THREE.Vector3().crossVectors(up, new THREE.Vector3(0, 1, 0)).normalize();
  const forward = new THREE.Vector3().crossVectors(right, up).normalize();

  const moveSpeed = 0.5;
  const jumpStrength = 0.3;

  switch (action) {
    case 'forward': velocity.add(forward.multiplyScalar(moveSpeed)); break;
    case 'back': velocity.add(forward.multiplyScalar(-moveSpeed)); break;
    case 'left': velocity.add(right.multiplyScalar(-moveSpeed)); break;
    case 'right': velocity.add(right.multiplyScalar(moveSpeed)); break;
    case 'jump': velocity.add(up.multiplyScalar(jumpStrength)); break;
  }
}

// Gravity + Movement
function applyGravityAndMove() {
  const G = 0.05, surfaceOffset = 0.5, maxSpeed = 0.25, friction = 0.9;

  for (const id in players) {
    const { mesh, velocity } = players[id];
    const fromCenter = mesh.position.clone().sub(planet.position);
    const dist = fromCenter.length();
    const dir = fromCenter.clone().normalize();
    const surfaceDist = planetRadius + surfaceOffset;

    if (dist > surfaceDist + 0.01) {
      velocity.add(planet.position.clone().sub(mesh.position).normalize().multiplyScalar(G));
    } else {
      mesh.position.copy(planet.position.clone().add(dir.multiplyScalar(surfaceDist)));
    }

    mesh.position.addScaledVector(velocity, 1);

    // Clamp speed
    if (velocity.length() > maxSpeed) {
      velocity.setLength(maxSpeed);
    }

    // Apply friction
    velocity.multiplyScalar(friction);

    // Reorient
    mesh.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir));
  }
}

// Input
const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

function handleInput() {
  if (keys["ArrowUp"]) control(activePlayerId, "forward");
  if (keys["ArrowDown"]) control(activePlayerId, "back");
  if (keys["ArrowLeft"]) control(activePlayerId, "left");
  if (keys["ArrowRight"]) control(activePlayerId, "right");
  if (keys["Space"]) control(activePlayerId, "jump");
}

// Camera
function updateCam() {
  const x = radius * Math.sin(pitch) * Math.sin(yaw);
  const y = radius * Math.cos(pitch);
  const z = radius * Math.sin(pitch) * Math.cos(yaw);
  cam.position.set(x, y, z);
  cam.lookAt(0, 0, 0);
}

// Animate
function animate() {
  requestAnimationFrame(animate);
  updateCam();
  handleInput();
  applyGravityAndMove();
  renderer.autoClear = false;
  renderer.clear();
  renderer.render(bgScene, bgCam);
  renderer.render(scene, cam);
}
animate();

// Mouse Drag Camera
let dragging = false, px = 0, py = 0;
renderer.domElement.addEventListener('mousedown', e => { dragging = true; px = e.clientX; py = e.clientY; });
document.addEventListener('mouseup', () => dragging = false);
document.addEventListener('mousemove', e => {
  if (!dragging) return;
  const dx = e.clientX - px, dy = e.clientY - py;
  yaw -= dx * 0.005;
  pitch -= dy * 0.005;
  pitch = Math.max(0.01, Math.min(Math.PI - 0.01, pitch));
  px = e.clientX; py = e.clientY;
});

// Resize
window.addEventListener("resize", () => {
  cam.aspect = innerWidth / innerHeight;
  cam.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  bgMat.uniforms.vh.value = innerHeight;
});

// Optional camera spin
setInterval(() => { yaw += 0.00085 }, 16);
</script>

</body>
</html>
