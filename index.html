<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Pose Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: white; }
    canvas { display: block; }
    #sensorList {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      color: black;
      font-family: monospace;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="sensorList"></div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js';const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const sensorDisplay = document.getElementById("sensorList");

const sensorLinks = [
  ['shoulder', 'elbow'],
  ['elbow', 'wrist'],
  ['shoulder', 'torso'],
  ['torso', 'hip'],
  ['hip', 'knee'],
  ['knee', 'ankle']
];

function generateSensorReadings() {
  return {
    shoulder: new THREE.Vector3(0, 1.5, 0),
    elbow: new THREE.Vector3(0.5, 1, 0),
    wrist: new THREE.Vector3(0.8, 0.5, 0),
    torso: new THREE.Vector3(0, 1.2, 0),
    hip: new THREE.Vector3(0, 0.9, 0),
    knee: new THREE.Vector3(0, 0.5, 0.2),
    ankle: new THREE.Vector3(0, 0.1, 0.4)
  };
}

let sensorPoints = {};
let jointLines = [];

function createPose() {
  const sensors = generateSensorReadings();

  Object.values(sensorPoints).forEach(p => scene.remove(p));
  jointLines.forEach(l => scene.remove(l));
  sensorPoints = {};
  jointLines = [];

  const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 }); // pink
  const pointGeometry = new THREE.SphereGeometry(0.05);

  sensorDisplay.innerHTML = '<strong>Sensors:</strong><br>';

  for (const [name, pos] of Object.entries(sensors)) {
    const point = new THREE.Mesh(pointGeometry, pointMaterial);
    point.position.copy(pos);
    scene.add(point);
    sensorPoints[name] = point;

    sensorDisplay.innerHTML += `â€¢ ${name}<br>`;
  }

  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff }); // blue
  for (const [a, b] of sensorLinks) {
    const points = [sensorPoints[a].position, sensorPoints[b].position];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, lineMaterial);
    scene.add(line);
    jointLines.push(line);
  }
}

createPose();

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

setInterval(createPose, 2000);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

  </script>
</body>
</html>