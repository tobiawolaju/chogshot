<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Humanoid Pose Viewer</title>
  <style>
    body {
      margin: 0;
      background-color: white;
      font-family: Arial, sans-serif;
    }
    #sensorList {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="sensorList"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);const sensorListDiv = document.getElementById("sensorList");

const sensorData = {
  head: { parent: "spine", length: 0.2 },
  leftShoulder: { parent: "spine", length: 0.2 },
  rightShoulder: { parent: "spine", length: 0.2 },
  leftElbow: { parent: "leftShoulder", length: 0.3 },
  rightElbow: { parent: "rightShoulder", length: 0.3 },
  leftWrist: { parent: "leftElbow", length: 0.25 },
  rightWrist: { parent: "rightElbow", length: 0.25 },
  spine: { parent: null, length: 0 },
  leftHip: { parent: "spine", length: 0.25 },
  rightHip: { parent: "spine", length: 0.25 },
  leftKnee: { parent: "leftHip", length: 0.4 },
  rightKnee: { parent: "rightHip", length: 0.4 },
  leftAnkle: { parent: "leftKnee", length: 0.4 },
  rightAnkle: { parent: "rightKnee", length: 0.4 },
};

const sensors = {};
const lines = [];

function generatePose() {
  const positions = {};
  const root = new THREE.Vector3(0, 1, 0); // spine
  positions["spine"] = root;

  for (let name in sensorData) {
    const sensor = sensorData[name];
    if (sensor.parent) {
      const parentPos = positions[sensor.parent];
      const dir = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      const pos = parentPos.clone().add(dir.multiplyScalar(sensor.length));
      positions[name] = pos;
    }
  }

  return positions;
}

function updateSensors(pose) {
  sensorListDiv.innerHTML = "<strong>Sensors:</strong><br>";

  for (let name in pose) {
    const pos = pose[name];

    if (!sensors[name]) {
      const geometry = new THREE.SphereGeometry(0.025, 16, 16);
      const material = new THREE.MeshBasicMaterial({ color: 0xff69b4 });
      const sphere = new THREE.Mesh(geometry, material);
      scene.add(sphere);
      sensors[name] = sphere;
    }

    sensors[name].position.copy(pos);
    sensorListDiv.innerHTML += `${name}: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})<br>`;
  }

  // Remove old lines
  lines.forEach(line => scene.remove(line));
  lines.length = 0;

  for (let name in sensorData) {
    const sensor = sensorData[name];
    if (sensor.parent && pose[name] && pose[sensor.parent]) {
      const geometry = new THREE.BufferGeometry().setFromPoints([
        pose[sensor.parent], pose[name]
      ]);
      const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      lines.push(line);
    }
  }
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

function updatePose() {
  const pose = generatePose();
  updateSensors(pose);
}

camera.position.z = 2.5;

setInterval(updatePose, 2000);
animate();

  </script>
</body>
</html>