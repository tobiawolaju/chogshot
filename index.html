<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Pose Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: white; }
    canvas { display: block; }
    #sensorList {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      color: black;
      font-family: monospace;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="sensorList"></div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js';const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const sensorDisplay = document.getElementById("sensorList");

// Sensor connections
const sensorLinks = [
  ['a', 'b'],
  ['b', 'c'],
  ['c', 'd']
];

// Simulate real-world sensor streaming
function sensorData() {
  return {
    a: new THREE.Vector3(
      Math.sin(Date.now() * 0.001) * 0.5,
      1.5,
      0
    ),
    b: new THREE.Vector3(
      0.5 + Math.sin(Date.now() * 0.001 + 1) * 0.3,
      1.0,
      0.2
    ),
    c: new THREE.Vector3(
      0.8 + Math.sin(Date.now() * 0.001 + 2) * 0.2,
      0.5,
      -0.2
    ),
    d: new THREE.Vector3(
      0.6 + Math.cos(Date.now() * 0.001) * 0.2,
      0.2,
      0.4
    )
  };
}

let sensorPoints = {};
let jointLines = [];

function createPose() {
  const sensors = sensorData();

  Object.values(sensorPoints).forEach(p => scene.remove(p));
  jointLines.forEach(l => scene.remove(l));
  sensorPoints = {};
  jointLines = [];

  const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 }); // pink
  const pointGeometry = new THREE.SphereGeometry(0.05);

  sensorDisplay.innerHTML = '<strong>Sensors:</strong><br>';

  for (const [name, pos] of Object.entries(sensors)) {
    const point = new THREE.Mesh(pointGeometry, pointMaterial);
    point.position.copy(pos);
    scene.add(point);
    sensorPoints[name] = point;

    sensorDisplay.innerHTML += `â€¢ ${name}: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})<br>`;
  }

  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff }); // blue
  for (const [a, b] of sensorLinks) {
    const points = [sensorPoints[a].position, sensorPoints[b].position];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, lineMaterial);
    scene.add(line);
    jointLines.push(line);
  }
}

function animate() {
  requestAnimationFrame(animate);
  createPose();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

  </script>
</body>
</html>