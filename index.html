<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Pose Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js';const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Dummy sensor hierarchy
const sensorLinks = [
  ['shoulder', 'elbow'],
  ['elbow', 'wrist'],
  ['shoulder', 'torso'],
  ['torso', 'hip'],
  ['hip', 'knee'],
  ['knee', 'ankle']
];

// Generate dummy positions for sensors
function generateSensorReadings() {
  return {
    shoulder: new THREE.Vector3(0, 1.5, 0),
    elbow: new THREE.Vector3(0.5, 1, 0),
    wrist: new THREE.Vector3(0.8, 0.5, 0),
    torso: new THREE.Vector3(0, 1.2, 0),
    hip: new THREE.Vector3(0, 0.9, 0),
    knee: new THREE.Vector3(0, 0.5, 0.2),
    ankle: new THREE.Vector3(0, 0.1, 0.4)
  };
}

let sensorPoints = {};
let jointLines = [];

function createPose() {
  const sensors = generateSensorReadings();

  // Clear previous
  Object.values(sensorPoints).forEach(p => scene.remove(p));
  jointLines.forEach(l => scene.remove(l));
  sensorPoints = {};
  jointLines = [];

  // Create spheres for each sensor
  const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const pointGeometry = new THREE.SphereGeometry(0.05);

  for (const [name, pos] of Object.entries(sensors)) {
    const point = new THREE.Mesh(pointGeometry, pointMaterial);
    point.position.copy(pos);
    scene.add(point);
    sensorPoints[name] = point;
  }

  // Connect joints with lines
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  for (const [a, b] of sensorLinks) {
    const points = [sensorPoints[a].position, sensorPoints[b].position];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, lineMaterial);
    scene.add(line);
    jointLines.push(line);
  }
}

createPose();

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// Optional: Regenerate every 2 seconds to simulate dynamic pose
setInterval(createPose, 2000);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

  </script>
</body>
</html>