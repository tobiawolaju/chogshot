<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Pose Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: white; }
    canvas { display: block; }
    #sensorList {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      color: black;
      font-family: monospace;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="sensorList"></div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js';const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const sensorDisplay = document.getElementById("sensorList");

const sensorLinks = [
  ['left_shoulder', 'left_elbow'],
  ['left_elbow', 'left_wrist'],
  ['right_shoulder', 'right_elbow'],
  ['right_elbow', 'right_wrist'],
  ['left_shoulder', 'spine'],
  ['right_shoulder', 'spine'],
  ['spine', 'left_hip'],
  ['spine', 'right_hip'],
  ['left_hip', 'left_knee'],
  ['left_knee', 'left_ankle'],
  ['right_hip', 'right_knee'],
  ['right_knee', 'right_ankle']
];

const limbLengths = {
  upper_arm: 0.4,
  lower_arm: 0.4,
  upper_leg: 0.5,
  lower_leg: 0.4,
  shoulder_spine: 0.2,
  spine_hip: 0.3
};

function sensorData() {
  const spine = new THREE.Vector3(0, 1.3, 0);

  const leftShoulder = spine.clone().add(new THREE.Vector3(-0.2, limbLengths.shoulder_spine, 0));
  const rightShoulder = spine.clone().add(new THREE.Vector3(0.2, limbLengths.shoulder_spine, 0));

  const leftElbow = leftShoulder.clone().add(new THREE.Vector3(
    Math.sin(Date.now() * 0.001) * 0.2, -1, 0.2
  ).normalize().multiplyScalar(limbLengths.upper_arm));

  const leftWrist = leftElbow.clone().add(new THREE.Vector3(
    0.2, -1, 0
  ).normalize().multiplyScalar(limbLengths.lower_arm));

  const rightElbow = rightShoulder.clone().add(new THREE.Vector3(
    Math.sin(Date.now() * 0.001 + 1), -1, -0.2
  ).normalize().multiplyScalar(limbLengths.upper_arm));

  const rightWrist = rightElbow.clone().add(new THREE.Vector3(
    0.2, -1, 0
  ).normalize().multiplyScalar(limbLengths.lower_arm));

  const leftHip = spine.clone().add(new THREE.Vector3(-0.15, -limbLengths.spine_hip, 0));
  const rightHip = spine.clone().add(new THREE.Vector3(0.15, -limbLengths.spine_hip, 0));

  const leftKnee = leftHip.clone().add(new THREE.Vector3(
    0, -1, 0.1
  ).normalize().multiplyScalar(limbLengths.upper_leg));

  const leftAnkle = leftKnee.clone().add(new THREE.Vector3(
    0, -1, 0.2
  ).normalize().multiplyScalar(limbLengths.lower_leg));

  const rightKnee = rightHip.clone().add(new THREE.Vector3(
    0, -1, -0.1
  ).normalize().multiplyScalar(limbLengths.upper_leg));

  const rightAnkle = rightKnee.clone().add(new THREE.Vector3(
    0, -1, -0.2
  ).normalize().multiplyScalar(limbLengths.lower_leg));

  return {
    left_shoulder: leftShoulder,
    right_shoulder: rightShoulder,
    left_elbow: leftElbow,
    right_elbow: rightElbow,
    left_wrist: leftWrist,
    right_wrist: rightWrist,
    spine: spine,
    left_hip: leftHip,
    right_hip: rightHip,
    left_knee: leftKnee,
    right_knee: rightKnee,
    left_ankle: leftAnkle,
    right_ankle: rightAnkle
  };
}

let sensorPoints = {};
let jointLines = [];

function createPose() {
  const sensors = sensorData();

  Object.values(sensorPoints).forEach(p => scene.remove(p));
  jointLines.forEach(l => scene.remove(l));
  sensorPoints = {};
  jointLines = [];

  const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff69b4 });
  const pointGeometry = new THREE.SphereGeometry(0.05);

  sensorDisplay.innerHTML = '<strong>Sensors:</strong><br>';

  for (const [name, pos] of Object.entries(sensors)) {
    const point = new THREE.Mesh(pointGeometry, pointMaterial);
    point.position.copy(pos);
    scene.add(point);
    sensorPoints[name] = point;
    sensorDisplay.innerHTML += `â€¢ ${name}: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})<br>`;
  }

  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
  for (const [a, b] of sensorLinks) {
    const points = [sensorPoints[a].position, sensorPoints[b].position];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, lineMaterial);
    scene.add(line);
    jointLines.push(line);
  }
}

function animate() {
  requestAnimationFrame(animate);
  createPose();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

  </script>
</body>
</html>