<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flawless Planet Gravity with cannon-es</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
    canvas { display: block; width: 100%; height: 100%; }
    .info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      font-family: monospace;
      font-size: 16px;
      text-shadow: 0 0 5px #000;
    }
  </style>
</head>
<body>
<div class="info">Use WASD to move the yellow sphere. Press SPACE to jump.</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
    "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as CANNON from 'cannon-es';


var planetRadius = 3
// --- Configuration ---
const config = {
    gravityConstant: 6.674e-2,
    planetMass: 50000,
    planetRadius: 5,
    cameraStartPos: new THREE.Vector3(0, 15, 25),
    playerMoveForce: 35,
    playerJumpForce: 30,
};

// --- Scene Setup ---
let scene, camera, renderer, controls;
let world;
const physicsObjects = [];
let planet;

// --- Player Control State ---
let player;
const keysPressed = {};
let playerCanJump = false;

// --- Main Initialization ---
function init() {
    setupScene();
    setupPhysics();
    setupLighting();
    setupEnvironment();
    createPlanet();
    createInitialBodies();
    setupEventListeners();
    animate();
}

// --- Setup Functions ---
function setupScene() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.copy(config.cameraStartPos);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
}

function setupPhysics() {
    world = new CANNON.World();
    world.gravity.set(0, 0, 0);
    world.allowSleep = true;
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.solver.iterations = 30;
    const defaultMaterial = new CANNON.Material('default');
    const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
        friction: 0.4,
        restitution: 0.0,
        contactEquationStiffness: 1e8,
        contactEquationRelaxation: 3,
    });
    world.addContactMaterial(contactMaterial);
    world.defaultContactMaterial = contactMaterial;
}

function setupLighting() {
   
// Lighting - 4 shepherd lights around the planet
const lightIntensity = 1;
const lightDistance = 1;

const lights = [
  new THREE.DirectionalLight(0xffffff, lightIntensity/2), // Right
  new THREE.DirectionalLight(0x00bcd4, lightIntensity), // Left
  new THREE.DirectionalLight(0xffed3f, lightIntensity), // Top
  new THREE.DirectionalLight(0xffffff, lightIntensity)  // Bottom
];

// Position the lights around the planet like satellites
lights[0].position.set(lightDistance, 10, 0);   // +X
lights[1].position.set(-lightDistance, 100, 0);  // -X
lights[2].position.set(0, lightDistance, 20);   // +Y
lights[3].position.set(200, -lightDistance, 0);  // -Y

lights.forEach(light => {
  light.castShadow = false; // optional
  scene.add(light);
});

// Ambient light to soften shadows
scene.add(new THREE.AmbientLight(0x444444));
}

function setupEnvironment() {
    const bgScene = new THREE.Scene(), bgCam = new THREE.Camera();
const bgMat = new THREE.ShaderMaterial({
  vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
  fragmentShader: `
    uniform vec3 topColor, middleColor, bottomColor; uniform float vh;
    void main() {
      float g = gl_FragCoord.y / vh;
      vec3 c = g < 0.5 ? mix(bottomColor, middleColor, g*2.0) : mix(middleColor, topColor, (g-0.5)*2.0);
      gl_FragColor = vec4(c, 1.0);
    }
  `,
  uniforms: {
    topColor: { value: new THREE.Color(0xE4EFFF) },
    middleColor: { value: new THREE.Color(0xFFFFFF) },
    bottomColor: { value: new THREE.Color(0xF7DDFF) },
    vh: { value: innerHeight }
  },
  depthWrite: false, depthTest: false, side: THREE.DoubleSide
});
scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), bgMat));


    // Starfield
const stars = new THREE.Object3D();
const starGeo = new THREE.TetrahedronGeometry(2, 0);
const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
for (let i = 0; i < 500; i++) {
  const star = new THREE.Mesh(starGeo, starMat);
  star.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
  star.position.multiplyScalar(90 + Math.random() * 700);
  star.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
  stars.add(star);
}
scene.add(stars);

function createCloudShaderMaterial() {
    return new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        cloudsSpeed: { value: 0.2 },
        cloudsDirection: { value: 0.2 },
        cloudsScale: { value: 1.0 },
        cloudsCutoff: { value: 0.3 },
        cloudsFuzziness: { value: 0.5 },
        cloudsColor: { value: new THREE.Color(1.0, 1.0, 1.0) },
        edgeFade: { value: 0.25 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float time, cloudsSpeed, cloudsDirection, cloudsScale, cloudsCutoff, cloudsFuzziness, edgeFade;
        uniform vec3 cloudsColor;

        float hash(vec2 p) {
          return fract(sin(dot(p ,vec2(127.1,311.7))) * 43758.5453);
        }
        float noise(vec2 p){
          vec2 i = floor(p), f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        float edge(vec2 uv) {
          vec2 f = smoothstep(vec2(0.0), vec2(edgeFade), uv);
          f *= smoothstep(vec2(0.0), vec2(edgeFade), 1.0 - uv);
          return f.x * f.y;
        }
        void main() {
          vec2 uv = vUv * cloudsScale;
          vec2 dir = vec2(sin(cloudsDirection * 6.2831), cos(cloudsDirection * 6.2831));
          vec2 moved = uv + dir * time * cloudsSpeed * 0.01;
          float n = (noise(moved * 1.0) + noise(moved * 2.0) + noise(moved * 4.0)) / 3.0;
          float alpha = smoothstep(cloudsCutoff, cloudsCutoff + cloudsFuzziness, n);
          gl_FragColor = vec4(cloudsColor, alpha * edge(vUv));
        }
      `,
      transparent: true,
      depthWrite: false
    });
  }


 
  //dummy planets ref
  const planet = new THREE.Mesh(
  new THREE.SphereGeometry(0, 1, 1),
);
scene.add(planet);
function addCloudCluster(pos) {
    const cloudGroup = new THREE.Group();
    const up = pos.clone().sub(planet.position).normalize();
    const cloudDistance = planetRadius + 5;
    const center = planet.position.clone().add(up.multiplyScalar(cloudDistance));
    const spiralTightness = 0.3, spiralGrowth = 0.2, totalPuffs = 60, spiralTurns = 4;

    for (let i = 0; i < totalPuffs; i++) {
      const angle = (i / totalPuffs) * spiralTurns * Math.PI * 2;
      const r = spiralTightness * Math.exp(spiralGrowth * angle);
      const x = r * Math.cos(angle);
      const y = (i / totalPuffs) * 4 - 2;
      const z = r * Math.sin(angle);
      const puffPosition = new THREE.Vector3(x, y, z).add(new THREE.Vector3(
        (Math.random() - 0.5) * 0.8,
        (Math.random() - 0.5) * 0.6,
        (Math.random() - 0.5) * 0.8
      ));
      const puff = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.25 + Math.random() * 0.2, 1),
        createCloudShaderMaterial()
      );
      puff.position.copy(center.clone().add(puffPosition));
      puff.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      const scale = 0.8 + Math.random() * 0.5;
      puff.scale.set(scale, scale * 0.8, scale);
      cloudGroup.add(puff);
    }
    cloudGroup.tick = delta => cloudGroup.rotation.y += 0.05 * delta;
    scene.add(cloudGroup);
    return cloudGroup;
  }

  const cloudClusters = [
    new THREE.Vector3(2, 5, 1), new THREE.Vector3(-3, -2, 4),
    new THREE.Vector3(4, -3, -5), new THREE.Vector3(-5, 2, -2),
    new THREE.Vector3(0, -4, 5)
  ].map(pos => addCloudCluster(pos));


}

class PhysicsObject {
    constructor(options) {
        this.isPlanet = options.isPlanet || false;
        this.isPlayer = options.isPlayer || false;
        
        const geometry = options.shapeType === 'sphere' 
            ? new THREE.SphereGeometry(options.size, 32, 32) 
            : new THREE.BoxGeometry(options.size, options.size, options.size);
            
        const material = new THREE.MeshStandardMaterial({ color: options.color || 0xff0000 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;

        if(this.isPlanet){
const planet = new THREE.Mesh(
  new THREE.SphereGeometry(options.size, 128, 128),
  new THREE.ShaderMaterial({
    vertexShader: `
      varying vec3 vNormal;
      varying vec2 vUv;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vNormal;
      varying vec2 vUv;
      float line(float val, float target, float thickness) {
        return smoothstep(target - thickness, target, val) - smoothstep(target, target + thickness, val);
      }
      float drawCourt(vec2 uv) {
        float t = 0.0025;
        float result = 0.0;
        float d = distance(uv, vec2(0.5, 0.5));
        result += smoothstep(0.06 + t, 0.06, d) - smoothstep(0.06, 0.06 - t, d);
        result += line(uv.x, 0.5, t);
        result += line(uv.y, 0.2, t);
        result += line(uv.y, 0.8, t);
        result += line(uv.x, 0.3, t);
        result += line(uv.x, 0.7, t);
        result += line(uv.y, 0.35, t);
        result += line(uv.y, 0.65, t);
        return clamp(result, 0.0, 1.0);
      }
      void main() {
        vec3 courtColor = vec3(1.0, 0.8, 1.0);
        vec3 lineColor = vec3(0.5, 0.5, 1.0);
        float lines = drawCourt(vUv);
        vec3 color = mix(courtColor, lineColor, lines);
        vec3 lightDir = normalize(vec3(0.3, 0.5, 1.0)); 
        float diffuse = max(dot(vNormal, lightDir), 0.0);
        color *= diffuse + 0.2;
        gl_FragColor = vec4(color, 1.0);
      }
    `,
    side: THREE.DoubleSide
  })
);
scene.add(planet);
        }else{
        scene.add(this.mesh);
        }
        
        const shape = options.shapeType === 'sphere' 
            ? new CANNON.Sphere(options.size) 
            : new CANNON.Box(new CANNON.Vec3(options.size / 2, options.size / 2, options.size / 2));
        
        this.body = new CANNON.Body({
            mass: options.mass,
            shape: shape,
            position: new CANNON.Vec3().copy(options.position),
            allowSleep: true,
            sleepSpeedLimit: 0.2,
            sleepTimeLimit: 0.5,
        });

        if (this.isPlayer) {
            this.body.allowSleep = false;
        }

        this.body.linearDamping = 0.5;
        this.body.angularDamping = 0.5;
        world.addBody(this.body);
        physicsObjects.push(this);
    }
    update() {
        if (!this.isPlanet) {
            applyRealisticGravity(this.body, planet.body, config.gravityConstant, config.planetMass);
        }
        this.mesh.position.copy(this.body.position);
        this.mesh.quaternion.copy(this.body.quaternion);
    }
}

function createPlanet() {
    planet = new PhysicsObject({
        isPlanet: true,
        shapeType: 'sphere',
        size: config.planetRadius,
        mass: 0,
        position: new THREE.Vector3(0, 0, 0),
        color: 0x228b22,
    });
    planet.mesh.receiveShadow = true;
    planet.mesh.castShadow = false;

    
}

function createInitialBodies() {
    player = new PhysicsObject({
        isPlayer: true,
        mass: 5,
        shapeType: 'sphere',
        size: 0.4,
        position: new THREE.Vector3(0, 8, 0),
        color: 0xffff00
    });
    
    player.body.addEventListener('collide', (event) => {
        playerCanJump = true;
    });

    // =========================================================
    // THIS IS THE CHANGED PART
    // =========================================================
    new PhysicsObject({ mass: 1, shapeType: 'sphere', size: 0.25, position: new THREE.Vector3(-3, 8, 1) });
    new PhysicsObject({ mass: 1, shapeType: 'sphere', size: 0.25, position: new THREE.Vector3(1, 9, -3) });
    new PhysicsObject({ mass: 1, shapeType: 'sphere', size: 0.25, position: new THREE.Vector3(4, 7, 2) });
}

function applyRealisticGravity(body, planetBody, G, planetMass) {
    const bodyPos = body.position;
    const planetPos = planetBody.position;
    const distVec = new CANNON.Vec3();
    planetPos.vsub(bodyPos, distVec);
    const distanceSq = distVec.lengthSquared();
    if (distanceSq < (config.planetRadius * config.planetRadius)) {
        return;
    }
    const forceMagnitude = G * (body.mass * planetMass) / distanceSq;
    distVec.normalize();
    distVec.scale(forceMagnitude, distVec);
    body.applyForce(distVec, bodyPos);
}

function handlePlayerInput() {
    if (!player) return;
    const playerUp = new THREE.Vector3().copy(player.body.position).normalize();
    if (keysPressed[' '] && playerCanJump) {
        const jumpImpulse = new CANNON.Vec3().copy(playerUp).scale(config.playerJumpForce);
        player.body.applyImpulse(jumpImpulse);
        playerCanJump = false;
    }
    const moveDirection = new THREE.Vector3(0, 0, 0);
    const cameraForward = new THREE.Vector3();
    camera.getWorldDirection(cameraForward);
    const tangentRight = new THREE.Vector3().crossVectors(playerUp, cameraForward).normalize();
    const tangentForward = new THREE.Vector3().crossVectors(tangentRight, playerUp).normalize();
    if (keysPressed['w']) moveDirection.add(tangentForward);
    if (keysPressed['s']) moveDirection.sub(tangentForward);
    if (keysPressed['a']) moveDirection.sub(tangentRight);
    if (keysPressed['d']) moveDirection.add(tangentRight);
    if (moveDirection.lengthSq() > 0) {
        moveDirection.normalize();
        const force = new CANNON.Vec3().copy(moveDirection).scale(config.playerMoveForce);
        player.body.applyForce(force);
    }
}

function setupEventListeners() {
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('keydown', (event) => { keysPressed[event.key.toLowerCase()] = true; });
    window.addEventListener('keyup', (event) => { keysPressed[event.key.toLowerCase()] = false; });
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

const timeStep = 1 / 60;
let lastTime;

function animate(time) {
    requestAnimationFrame(animate);
    if (lastTime !== undefined) {
        const dt = (time - lastTime) / 1000;
        handlePlayerInput();
        world.step(timeStep, dt, 10);
    }
    lastTime = time;
    physicsObjects.forEach(obj => obj.update());
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>